\newpage
%

\chapter{Compiling, running and debugging}
\label{sec_compilationrunning}

\section{Compiling OASIS3-MCT}
\label{subsec_compile}

Compiling OASIS3-MCT can be done in directory {\tt oasis3-MCT/util/make\_dir}
with Makefile \\ {\tt TopMakefileOasis3} which must be completed with a header file {\tt
  make.{\it your\_platform}} specific to the compiling platform used
and specified in {\tt oasis3-MCT/util/make\_dir/make.inc}.  One of the
header files distributed with the release can by used as a template.  The root 
of the OASIS3-MCT tree
can be anywhere and must be set in the variable {\tt COUPLE} in the
{\tt make.{\it your\_platform}} file. 

The following commands are available:

\begin{itemize}
\item {\tt make -f TopMakefileOasis3} or {\tt make oasis3\_psmile -f
  TopMakefileOasis3} (for backward compatibility):

  compiles all OASIS3-MCT libraries {\it mct}, {\it scrip} and {\it psmile}; 

\item {\tt make realclean -f  TopMakefileOasis3}: 

  removes all OASIS3-MCT compiled sources and librairies.

\end{itemize}

Log and error messages from compilation are saved in the files
COMP.log and COMP.err in make\_dir.

During compilation, a new compiling directory, defined by variable {\tt ARCHDIR}
is created.  After successful
compilation, resulting libraries are found in the compiling directory in {\tt /lib} and object
and module files in {\tt /build}. If mod\_oasis is used in the models, it is enough to include the path of the psmile
objects and modules for the compilation and to use the psmile library when linking. If mod\_prism is used in the models, it is 
necessary to include the path of the psmile and of the mct objects and modules for the compilation and to use both the psmile and 
mct libraries when linking.

The following CPP keys are coded in OASIS3-MCT and
can be specified in {\tt CPPDEF} in {\tt make.{\it your\_platform}} file.

\begin{itemize}

\item {\tt TREAT\_OVERLAY}: To ensure, in {\tt SCRIPR/CONSERV} remapping (see section
  \ref{subsec_interp}), that if two cells of the source grid overlay,
  at least the one with the greater numerical index is masked (they
  also can be both masked); this is mandatory for this remapping. For
  example, if the grid line with i=1 overlaps the grid line with
  i=imax, it is the latter that must be masked; when this is not the
  case with the mask defined in {\it masks.nc}, this CPP key forces
  these rules are to be respected.

\item {\tt balance}: Add a MPI\_Wtime() function before and after mct\_isend (MPI put)
   and mct\_recv (MPI get) to calculate the time of the send and receive of a coupling field. This option can be used to produce timestamps in OASIS debug files. During a post-processing phase, this information can be used to perform
an analysis of the coupled components load (un)balance; specific tools have
been developed to do this and will be released with a further version of
OASIS3-MCT."

\end{itemize}

\section{Running OASIS3-MCT}
\label{subsec_running}

A practical example on how to run OASIS3-MCT and running it in a
coupled system is provided in {\tt oasis3-mct/examples/tutorial}. For
more details, see the README there in.

\section{Debugging}
\label{subsec_debug}

\subsection{Debug files}
If you experience problems while running your coupled model with
OASIS3-MCT, you can obtain more information on what is happening by increasing {\tt \$NLOGPRT} 
in your {\it namcouple} (see also section \ref{subsec_namcouplefirst}).

Different output are written depending on NLOGPRT value:
\begin{itemize}
\item {0}  : one file debug.root.xx is open by the master proces of each model and one file debug\_notroot.xx is open for all the other processes of each model to write only error information if an error occurs.
\item {1}  : one file debug.root.xx is open by the master proces of each model to write information equivalent to level 10 (see below); one file debug\_notroot.xx is open for all the other processes of each model to write only error information if an error occurs.
\item {2}  : one file debug.xx.xxxxxx is open by each process of each model to write normal production diagnostics.
\item {5}  : as for 2 with in addition some initial debug info.
\item {10} : as for 5 with in addition the routine calling tree.
\item {12} : as for 10 with in addition some routine calling notes.
\item {15} : as for 12 with even more debug diagnostics.
\item {20} : as for 15 with in addition some extra runtime analysis.
\item {30} : full debug information.
\end{itemize}

\subsection{Time statistics files}

The variable TIMER\_Debug, defined in mod\_oasis\_timer, is used to obtain time statistics over all the processors for each routine.

Different output are written (in files named *.timers\_xxxx) depending on TIMER\_Debug value :

\begin{itemize}
\item {TIMER\_Debug=0} : nothing is calculated, nothing is written.
\item {TIMER\_Debug=1} : the times are calculated and written in a single file by the processor 0 as well as 
the min and the max times over all the processors.
\item {TIMER\_Debug=2} : the times are calculated and each processor writes its own file ; processor 0 also 
writes the min and the max times over all the processors in its file.
\item {TIMER\_Debug=3} : the times are calculated and each processor writes its own file ; processor 0 also 
writes in its file the min and the max times over all processors and also writes in its file all the results for each processor.
\end{itemize}

The time given for each timer is calculated by the difference between calls to {\tt  oasis\_timer\_start()} and {\tt oasis\_timer\_stop()} and is the accumulated time over the entire run. Here is an overview of the meaning of the different timers as implemented by default. 

\begin{itemize}
\item {'total after init'} : total time of the simulation, implemented in {\tt mod\_oasis\_method}, i.e. between the end of {\tt oasis\_init\_comp} and the call to {\tt mpi\_barrier} and {\tt mpi\_finalize} in routine {\tt oasis\_terminate}.
\item {'map definition'} : time spent in {\tt mct\_gsmap\_init} in routine {\tt oasis\_def\_partition}; this routine defines the patterns of communication between the source and target processes.
\item {'cpl\_setup'} :time spent in {\tt oasis\_coupler\_setup}, which sets up additional coupling aspects related to {\tt oasis\_method\_enddef}.
\item {'cpl\_smatrd'} : time spent in {\tt oasis\_coupler\_smatreaddnc} in {\tt mod\_oasis\_coupler} (routine {\tt oasis\_coupler\_setup}); this routine performs a distributed read of a NetCDF SCRIP file and returns weights in a distributed SparseMatrix, and calls {\tt mct\_sMatP\_Init} which initialises the sparse matrix vector multiplication.
\item {'oasis\_advance\_init()'} : time spent in {\tt oasis\_advance\_init}, which handles reading of initial coupling  restart and communication of data for fields with positive lags.
\item {'grcv\_00x'} : time spent in the reception of field x in {\tt mct\_recv} (including communication and possible waiting time linked to unbalance of components).
\item {'wout\_00x'} : time spent in the I/O for field x in routine {\tt oasis\_advance\_run}.
\item {'gcpy\_00x'} : time spent in routine {\tt oasis\_advance\_run} in copying the field x just received in a local array.
\item {'pcpy\_00x'} : time spent in routine {\tt oasis\_advance\_run} in copying the local field x in the array to send (i.e. with local transformation besides division for averaging).
\item {'pavg\_00x'} : time spent in routine {\tt oasis\_advance\_run} to calculate the average of field x (if done).
\item {'pmap\_00x'/'gmap\_00x'} : time spent in routine {\tt oasis\_advance\_run} for the matrix vector multiplication for field x on the source/target processes.
\item {'psnd\_00x'} : time spent in routine {\tt oasis\_advance\_run} for sending field x (i.e. including call to {\tt mct\_waitsend} and {\tt mct\_isend}).
\end{itemize}

